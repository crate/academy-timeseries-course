<h3>Video Transcript</h3>
<p><span data-contrast="none">Time series applications work with real-time data in most of the cases. This chapter will provide an example how data can be streamed into CrateDB using Apache Kafka and Apache Flink.</span><span data-ccp-props="{&quot;134233117&quot;:false,&quot;134233118&quot;:false,&quot;201341983&quot;:0,&quot;335551550&quot;:1,&quot;335551620&quot;:1,&quot;335559685&quot;:0,&quot;335559737&quot;:0,&quot;335559738&quot;:0,&quot;335559739&quot;:0,&quot;335559740&quot;:276}">&nbsp;</span></p>
<p><span data-contrast="none">Ingesting time series data in a streaming fashion is crucial for several reasons. Firstly, streaming ingestion of time series data ensures that the database is always up-to-date, enabling accurate and current insights. Furthermore, it allows for real-time analysis and decision making, which is particularly important for industries where immediate action based on the latest data can lead to significant operational improvements or prevent potential issues. Lastly, it can efficiently handle the high volume and velocity of time series data, ensuring that the system can keep up with the data flow and prevent data loss.</span><span data-ccp-props="{&quot;134233117&quot;:false,&quot;134233118&quot;:false,&quot;201341983&quot;:0,&quot;335551550&quot;:1,&quot;335551620&quot;:1,&quot;335559685&quot;:0,&quot;335559737&quot;:0,&quot;335559738&quot;:0,&quot;335559739&quot;:0,&quot;335559740&quot;:276}">&nbsp;</span></p>
<p><span data-contrast="none">The architecture of the demo is designed to handle real-time ingestion and processing of time series data. It starts by frequently querying a Weather API through HTTP requests to gather the latest weather data. This data is then pushed into a Kafka topic, serving as a buffer and ensuring no data is lost even if there's a spike in incoming data. Then, a Flink job is used to consume the data from Kafka and incrementally ingest it into CrateDB. This architecture enables real-time data analysis, as the data in CrateDB is kept up-to-date with the latest weather conditions and other services can read either directly from the stream or from CrateDB. You can find the demo artifacts in our GitHub examples repository.</span><span data-ccp-props="{&quot;134233117&quot;:false,&quot;134233118&quot;:false,&quot;201341983&quot;:0,&quot;335551550&quot;:1,&quot;335551620&quot;:1,&quot;335559685&quot;:0,&quot;335559737&quot;:0,&quot;335559738&quot;:0,&quot;335559739&quot;:0,&quot;335559740&quot;:276}">&nbsp;</span></p>
<p><span data-contrast="none">In addition to the streaming data, this example&nbsp;demonstrates how easy it is to work with JSON data and how CrateDB’s flexible schema speeds up the development process.</span><span data-ccp-props="{&quot;134233117&quot;:false,&quot;134233118&quot;:false,&quot;201341983&quot;:0,&quot;335551550&quot;:1,&quot;335551620&quot;:1,&quot;335559685&quot;:0,&quot;335559737&quot;:0,&quot;335559738&quot;:0,&quot;335559739&quot;:0,&quot;335559740&quot;:276}">&nbsp;</span></p>
<p><span data-contrast="none">A complete JSON record is returned from the weather service with information about the location and the current weather conditions. As the details of both sections can change over time, both are created as dynamic objects in CrateDB. There is no need for a complex schema and type conversions while keeping the ability to automatically index all individual attributes for fast filtering and aggregations. Without further ado, one can create aggregations like the calculation of the average temperature in France.</span><span data-ccp-props="{&quot;134233117&quot;:false,&quot;134233118&quot;:false,&quot;201341983&quot;:0,&quot;335551550&quot;:1,&quot;335551620&quot;:1,&quot;335559685&quot;:0,&quot;335559737&quot;:0,&quot;335559738&quot;:0,&quot;335559739&quot;:0,&quot;335559740&quot;:276}">&nbsp;</span></p>
<p><span data-contrast="none">Also, the development process itself gets much easier. On the producer side, we can easily dump the JSON file into the Kafka topic. The Flink schema represents the two location and current conditions attributes, both represented as Strings, i.e. JSON-formatted text.</span><span>&nbsp;<br></span></p>
<p><span data-contrast="none">With the automatic interpretation of JSON text in CrateDB, the actual write into the database is executing a simple insert of these two attributes based on their textural representations. If new attributes are added to location or current, they are automatically added in CrateDB as well, incl. type inference and automatic indexing for immediate querying.</span><span data-ccp-props="{&quot;134233117&quot;:false,&quot;134233118&quot;:false,&quot;201341983&quot;:0,&quot;335551550&quot;:1,&quot;335551620&quot;:1,&quot;335559685&quot;:0,&quot;335559737&quot;:0,&quot;335559738&quot;:0,&quot;335559739&quot;:0,&quot;335559740&quot;:276}">&nbsp;</span></p>
<p><span data-contrast="none">Let us have a look at the actual demonstration of the streaming ingest process. You can find all the resources in our cratedb examples repository on GitHub.&nbsp;</span><span data-ccp-props="{&quot;134233117&quot;:false,&quot;134233118&quot;:false,&quot;201341983&quot;:0,&quot;335551550&quot;:1,&quot;335551620&quot;:1,&quot;335559685&quot;:0,&quot;335559737&quot;:0,&quot;335559738&quot;:0,&quot;335559739&quot;:0,&quot;335559740&quot;:276}">&nbsp;</span></p>
<p><span data-contrast="none">As a first step, please clone the repository to your local machine.</span><span data-ccp-props="{&quot;134233117&quot;:false,&quot;134233118&quot;:false,&quot;201341983&quot;:0,&quot;335551550&quot;:1,&quot;335551620&quot;:1,&quot;335559685&quot;:0,&quot;335559737&quot;:0,&quot;335559738&quot;:0,&quot;335559739&quot;:0,&quot;335559740&quot;:276}">&nbsp;</span></p>
<p><span data-contrast="none">Once this is done, please change into the Apache Kafka Flink streaming directory. It contains a couple of resources that we will use to demonstrate the ingest.</span><span data-ccp-props="{&quot;134233117&quot;:false,&quot;134233118&quot;:false,&quot;201341983&quot;:0,&quot;335551550&quot;:1,&quot;335551620&quot;:1,&quot;335559685&quot;:0,&quot;335559737&quot;:0,&quot;335559738&quot;:0,&quot;335559739&quot;:0,&quot;335559740&quot;:276}">&nbsp;</span></p>
<p><span data-contrast="none">The env file contains multiple parameters that we need to set before we can start the demo via docker compose. In order to read the data from the weather API, we need to acquire a free API key. Please visit their website weatherapi.com, sign up for a free account and generate a new API key. We will copy it into our <code>.env</code> file. Furthermore, we configure to collect new data every 5 seconds from the service.</span><span data-ccp-props="{&quot;134233117&quot;:false,&quot;134233118&quot;:false,&quot;201341983&quot;:0,&quot;335551550&quot;:1,&quot;335551620&quot;:1,&quot;335559685&quot;:0,&quot;335559737&quot;:0,&quot;335559738&quot;:0,&quot;335559739&quot;:0,&quot;335559740&quot;:276}">&nbsp;</span></p>
<p><span data-contrast="none">After saving the configuration settings, we start the demo via docker compose. It will automatically download and start multiple images: Kafka and Flink, incl. zookeeper, CrateDB, as well as a producer forwarding the results of API calls into a Kafka topic.</span><span data-ccp-props="{&quot;134233117&quot;:false,&quot;134233118&quot;:false,&quot;201341983&quot;:0,&quot;335551550&quot;:1,&quot;335551620&quot;:1,&quot;335559685&quot;:0,&quot;335559737&quot;:0,&quot;335559738&quot;:0,&quot;335559739&quot;:0,&quot;335559740&quot;:276}">&nbsp;</span></p>
<p><span data-contrast="none">Once the download is complete, please open CrateDB’s admin UI in your web browser by opening <code>http://localhost:4200</code>. You will find an empty CrateDB instance in which we create the previously described table weather data Flink. It contains a generated timestamp to identify when a record has been inserted as well as the two sections location and current conditions as dynamic objects leveraging CrateDB's dynamic schema capabilities.</span><span data-ccp-props="{&quot;134233117&quot;:false,&quot;134233118&quot;:false,&quot;201341983&quot;:0,&quot;335551550&quot;:1,&quot;335551620&quot;:1,&quot;335559685&quot;:0,&quot;335559737&quot;:0,&quot;335559738&quot;:0,&quot;335559739&quot;:0,&quot;335559740&quot;:276}">&nbsp;</span></p>
<p><span data-contrast="none">Once the table is created, we see that the data from the Kafka topic is written automatically to CrateDB, i.e. the Flink job is running correctly. The first two records that existed in the Kafka topic by this time have been inserted successfully.&nbsp;</span><span data-ccp-props="{&quot;134233117&quot;:false,&quot;134233118&quot;:false,&quot;201341983&quot;:0,&quot;335551550&quot;:1,&quot;335551620&quot;:1,&quot;335559685&quot;:0,&quot;335559737&quot;:0,&quot;335559738&quot;:0,&quot;335559739&quot;:0,&quot;335559740&quot;:276}">&nbsp;</span></p>
<p><span data-contrast="none">Let us have a look at the actual data. As we can see, one more row has arrived in the meantime, and the structure from the web service call delivered in JSON has been correctly interpreted and inserted into the two objects. We can now use this data for further analysis as we demonstrated in the previous chapters about efficiently querying JSON data in CrateDB.</span></p>