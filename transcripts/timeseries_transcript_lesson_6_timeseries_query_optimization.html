<h3>Video Transcript</h3>
<p><span data-contrast="none">Time series data often presents unique challenges due to its large volume and temporal nature. Therefore, optimizing queries becomes crucial for maintaining performance and scalability. In this video, we'll explore essential techniques for efficiently querying time series data in CrateDB.</span><span data-ccp-props="{&quot;134233117&quot;:false,&quot;134233118&quot;:false,&quot;201341983&quot;:0,&quot;335551550&quot;:1,&quot;335551620&quot;:1,&quot;335559685&quot;:0,&quot;335559737&quot;:0,&quot;335559738&quot;:0,&quot;335559739&quot;:0,&quot;335559740&quot;:276}">&nbsp;</span></p>
<p><span data-contrast="none">To find bottlenecks and potential optimization opportunities in your time-series queries consider using the <code>EXPLAIN ANALYZE</code> command. When you prepend <code>EXPLAIN ANALYZE</code> to your SQL query, CrateDB not only generates the execution plan, but also runs the query and captures detailed runtime statistics. This includes the time spent in various operations such as parsing, planning, and the actual execution of the query. For CrateDB, which relies on Lucene indexes, <code>EXPLAIN ANALYZE</code> can offer insights into how queries are executed using Lucene's indexing mechanisms.</span><span data-ccp-props="{&quot;134233117&quot;:false,&quot;134233118&quot;:false,&quot;201341983&quot;:0,&quot;335551550&quot;:1,&quot;335551620&quot;:1,&quot;335559685&quot;:0,&quot;335559737&quot;:0,&quot;335559738&quot;:0,&quot;335559739&quot;:0,&quot;335559740&quot;:276}">&nbsp;</span></p>
<p><span data-contrast="none">In this example, we illustrate the time taken to run a <code>SELECT</code> query where certain conditions are applied, filtering data based on temperature. The time number represents the query execution time in milliseconds, while the green labels represent execution times for individual operations within the overall query, such as data scans, joins, or aggregations.</span><span data-ccp-props="{&quot;134233117&quot;:false,&quot;134233118&quot;:false,&quot;201341983&quot;:0,&quot;335551550&quot;:1,&quot;335551620&quot;:1,&quot;335559685&quot;:0,&quot;335559737&quot;:0,&quot;335559738&quot;:0,&quot;335559739&quot;:0,&quot;335559740&quot;:276}">&nbsp;</span></p>
<p><span data-contrast="none">These granular timings provide insight into the database's performance, helping us understand where optimizations can be made. For instance, if a particular operation is taking longer than expected, we might consider indexing strategies or query rewriting to enhance performance.</span><span data-ccp-props="{&quot;134233117&quot;:false,&quot;134233118&quot;:false,&quot;201341983&quot;:0,&quot;335551550&quot;:1,&quot;335551620&quot;:1,&quot;335559685&quot;:0,&quot;335559737&quot;:0,&quot;335559738&quot;:0,&quot;335559739&quot;:0,&quot;335559740&quot;:276}">&nbsp;</span></p>
<p><span data-contrast="none">A full table scan, where the database engine examines every single row in a table, can lead to performance issues. It's a process that is both CPU and I/O intensive and can lead to inefficient execution when dealing with large, time-series datasets.&nbsp;</span><span data-ccp-props="{&quot;134233117&quot;:false,&quot;134233118&quot;:false,&quot;201341983&quot;:0,&quot;335551550&quot;:1,&quot;335551620&quot;:1,&quot;335559685&quot;:0,&quot;335559737&quot;:0,&quot;335559738&quot;:0,&quot;335559739&quot;:0,&quot;335559740&quot;:276}">&nbsp;</span></p>
<p><span data-contrast="none">For instance, let's consider a query aimed at calculating the average temperature over a two-month period.&nbsp;</span><span data-ccp-props="{&quot;134233117&quot;:false,&quot;134233118&quot;:false,&quot;201341983&quot;:0,&quot;335551550&quot;:1,&quot;335551620&quot;:1,&quot;335559685&quot;:0,&quot;335559737&quot;:0,&quot;335559738&quot;:0,&quot;335559739&quot;:0,&quot;335559740&quot;:276}">&nbsp;</span></p>
<p><span data-contrast="none">Executing it on a non-sharded and non-portioned table requires a full table scan.&nbsp;</span><span data-ccp-props="{&quot;134233117&quot;:false,&quot;134233118&quot;:false,&quot;201341983&quot;:0,&quot;335551550&quot;:1,&quot;335551620&quot;:1,&quot;335559685&quot;:0,&quot;335559737&quot;:0,&quot;335559738&quot;:0,&quot;335559739&quot;:0,&quot;335559740&quot;:276}">&nbsp;</span></p>
<p><span data-contrast="none">Using partitioning and sharding avoids that all data needs to be scanned on the one hand and the aggregation can be executed in parallel on the different shards and partitions.</span><span data-ccp-props="{&quot;134233117&quot;:false,&quot;134233118&quot;:false,&quot;201341983&quot;:0,&quot;335551550&quot;:1,&quot;335551620&quot;:1,&quot;335559685&quot;:0,&quot;335559737&quot;:0,&quot;335559738&quot;:0,&quot;335559739&quot;:0,&quot;335559740&quot;:276}">&nbsp;</span></p>
<p><span data-contrast="none">Let’s look at this example in practice. We first need to create a new table and import weather data:</span><span data-ccp-props="{&quot;134233117&quot;:false,&quot;134233118&quot;:false,&quot;201341983&quot;:0,&quot;335551550&quot;:1,&quot;335551620&quot;:1,&quot;335559685&quot;:0,&quot;335559737&quot;:0,&quot;335559738&quot;:0,&quot;335559739&quot;:0,&quot;335559740&quot;:276}">&nbsp;</span><span data-contrast="none">&nbsp;</span><span data-ccp-props="{&quot;134233117&quot;:false,&quot;134233118&quot;:false,&quot;201341983&quot;:0,&quot;335551550&quot;:1,&quot;335551620&quot;:1,&quot;335559685&quot;:0,&quot;335559737&quot;:0,&quot;335559738&quot;:0,&quot;335559739&quot;:0,&quot;335559740&quot;:276}">&nbsp;</span></p>
<div>
<div><code><span>CREATE</span><span> </span><span>TABLE</span><span> </span><span>IF</span><span> </span><span>NOT</span><span> </span><span>EXISTS</span><span> </span><span>"doc"</span><span>.</span><span>"weather_data"</span><span> (</span></code></div>
<div><code><span>&nbsp;</span><span>&nbsp; &nbsp; "timestamp"</span><span> </span><span>TIMESTAMP WITHOUT TIME ZONE</span><span>,</span></code></div>
<div><code><span>&nbsp;</span><span>&nbsp; &nbsp; "location"</span><span> </span><span>TEXT</span><span>,</span></code></div>
<div><code><span>&nbsp;</span><span>&nbsp; &nbsp; "temperature"</span><span> </span><span>DOUBLE PRECISION</span><span>,</span></code></div>
<div><code><span>&nbsp;</span><span>&nbsp; &nbsp; "humidity"</span><span> </span><span>DOUBLE PRECISION</span><span>,</span></code></div>
<div><code><span>&nbsp;</span><span>&nbsp; &nbsp; "wind_speed"</span><span> </span><span>DOUBLE PRECISION</span></code></div>
<div><code><span>) </span><span>CLUSTERED</span><span> </span><span>INTO</span><span> </span><span>1</span><span> SHARDS;</span></code></div>
<br>
<div><code><span>COPY</span><span> weather_data</span></code></div>
<div><code><span>FROM</span><span> </span><span>'https://github.com/crate/cratedb-datasets/raw/main/cloud-tutorials/data_weather.csv.gz'</span></code></div>
<div><code><span>WITH</span><span> (format</span><span>=</span><span>'csv'</span><span>, </span><span>compression</span><span>=</span><span>'gzip'</span><span>, empty_string_as_null</span><span>=</span><span>true);</span></code></div>
<div><span>&nbsp;</span></div>
</div>
<p><span data-contrast="none">Now, let’s create another table as a partitioned table based on time intervals, such as monthly partitions. By doing this, we enable the CrateDB to quickly return just the relevant data needed for the query, bypassing all irrelevant records.&nbsp;</span><span data-ccp-props="{&quot;134233117&quot;:false,&quot;134233118&quot;:false,&quot;201341983&quot;:0,&quot;335551550&quot;:1,&quot;335551620&quot;:1,&quot;335559685&quot;:0,&quot;335559737&quot;:0,&quot;335559738&quot;:0,&quot;335559739&quot;:0,&quot;335559740&quot;:276}">&nbsp;</span></p>
<div>
<div><code><span>CREATE</span><span> </span><span>TABLE</span><span> </span><span>IF</span><span> </span><span>NOT</span><span> </span><span>EXISTS</span><span> </span><span>"doc"</span><span>.</span><span>"weather_data_partitioned"</span><span> (</span></code></div>
<div><code><span>&nbsp;</span><span>&nbsp; &nbsp; "timestamp"</span><span> </span><span>TIMESTAMP WITHOUT TIME ZONE</span><span>,</span></code></div>
<div><code><span>&nbsp;</span><span>&nbsp; &nbsp; "location"</span><span> </span><span>TEXT</span><span>,</span></code></div>
<div><code><span>&nbsp;</span><span>&nbsp; &nbsp; "temperature"</span><span> </span><span>DOUBLE PRECISION</span><span>,</span></code></div>
<div><code><span>&nbsp;</span><span>&nbsp; &nbsp; "humidity"</span><span> </span><span>DOUBLE PRECISION</span><span>,</span></code></div>
<div><code><span>&nbsp;</span><span>&nbsp; &nbsp; "wind_speed"</span><span> </span><span>DOUBLE PRECISION</span><span>,</span></code></div>
<div><code><span>&nbsp;</span><span>&nbsp; &nbsp; "ts_month"</span><span> </span><span>GENERATED</span><span> </span><span>ALWAYS</span><span> </span><span>AS</span><span> date_trunc(</span><span>'month'</span><span>, </span><span>"timestamp"</span><span>)</span></code></div>
<div><code><span>) </span><span>CLUSTERED</span><span> </span><span>INTO</span><span> </span><span>1</span><span> SHARDS</span></code></div>
<div><code><span>PARTITIONED </span><span>BY</span><span> (</span><span>"ts_month"</span><span>);</span></code></div>
<br>
<div><code><span>COPY</span><span> weather_data_partitioned</span></code></div>
<div><code><span>FROM</span><span> </span><span>'https://github.com/crate/cratedb-datasets/raw/main/cloud-tutorials/data_weather.csv.gz'</span></code></div>
<div><code><span>WITH</span><span> (format</span><span>=</span><span>'csv'</span><span>, </span><span>compression</span><span>=</span><span>'gzip'</span><span>, empty_string_as_null</span><span>=</span><span>true);</span></code></div>
<div><span>&nbsp;</span></div>
</div>
<p><span data-contrast="none">Let’s run the query on both, partitioned and non-partitioned tables and use the <code>EXPLAIN ANALYZE</code> command to better understand which partitions have been queried.</span><span data-ccp-props="{&quot;134233117&quot;:false,&quot;134233118&quot;:false,&quot;201341983&quot;:0,&quot;335551550&quot;:1,&quot;335551620&quot;:1,&quot;335559685&quot;:0,&quot;335559737&quot;:0,&quot;335559738&quot;:0,&quot;335559739&quot;:0,&quot;335559740&quot;:276}">&nbsp;</span></p>
<p><span data-contrast="none">The execution trace of the query on the non-partitioned table looks like the following:</span><span data-ccp-props="{&quot;134233117&quot;:false,&quot;134233118&quot;:false,&quot;201341983&quot;:0,&quot;335551550&quot;:1,&quot;335551620&quot;:1,&quot;335559685&quot;:0,&quot;335559737&quot;:0,&quot;335559738&quot;:0,&quot;335559739&quot;:0,&quot;335559740&quot;:276}">&nbsp;</span></p>
<div>
<div><code><span>EXPLAIN ANALYZE </span><span>SELECT</span></code></div>
<div><code><span>&nbsp; &nbsp; date_trunc(</span><span>'month'</span><span>, </span><span>"timestamp"</span><span>) </span><span>AS</span><span> </span><span>"month"</span><span>,</span></code></div>
<div><code><span>&nbsp;</span><span>&nbsp; &nbsp;AVG</span><span>(</span><span>"temperature"</span><span>) </span><span>AS</span><span> </span><span>"avg_temperature"</span><span>,</span></code></div>
<div><code><span>&nbsp;</span><span>&nbsp; &nbsp;AVG</span><span>(</span><span>"humidity"</span><span>) </span><span>AS</span><span> </span><span>"avg_humidity"</span><span>,</span></code></div>
<div><code><span>&nbsp;</span><span>&nbsp; &nbsp;AVG</span><span>(</span><span>"wind_speed"</span><span>) </span><span>AS</span><span> </span><span>"avg_wind_speed"</span></code></div>
<div><code><span>FROM</span><span> </span><span>"doc"</span><span>.</span><span>"weather_data"</span></code></div>
<div><code><span>WHERE</span><span> </span><span>"timestamp"</span><span> </span><span>&gt;=</span><span> </span><span>'2023-01-01'</span><span> </span><span>AND</span><span> </span><span>"timestamp"</span><span> </span><span>&lt;</span><span> </span><span>'2023-03-01'</span></code></div>
<div><code><span>GROUP BY</span><span> </span><span>"month"</span></code></div>
<div><code><span>ORDER BY</span><span> </span><span>"month"</span><span>;</span></code></div>
<div><span>&nbsp;</span></div>
</div>
<p><span data-contrast="none">Here we can see that one partition was queried. We can run the same query on partitioned table:</span><span data-ccp-props="{&quot;134233117&quot;:false,&quot;134233118&quot;:false,&quot;201341983&quot;:0,&quot;335551550&quot;:1,&quot;335551620&quot;:1,&quot;335559685&quot;:0,&quot;335559737&quot;:0,&quot;335559738&quot;:0,&quot;335559739&quot;:0,&quot;335559740&quot;:276}">&nbsp;</span></p>
<div>
<div><code><span>EXPLAIN ANALYZE </span><span>SELECT</span></code></div>
<div><code><span>&nbsp; &nbsp; ts_month,</span></code></div>
<div><code><span>&nbsp;</span><span>&nbsp; &nbsp;AVG</span><span>(</span><span>"temperature"</span><span>) </span><span>AS</span><span> </span><span>"avg_temperature"</span><span>,</span></code></div>
<div><code><span>&nbsp;</span><span>&nbsp; &nbsp;AVG</span><span>(</span><span>"humidity"</span><span>) </span><span>AS</span><span> </span><span>"avg_humidity"</span><span>,</span></code></div>
<div><code><span>&nbsp;</span><span>&nbsp; &nbsp;AVG</span><span>(</span><span>"wind_speed"</span><span>) </span><span>AS</span><span> </span><span>"avg_wind_speed"</span></code></div>
<div><code><span>FROM</span><span> </span><span>"doc"</span><span>.</span><span>"weather_data_partitioned"</span></code></div>
<div><code><span>WHERE</span><span> </span><span>"timestamp"</span><span> </span><span>&gt;=</span><span> </span><span>'2023-01-01'</span><span> </span><span>AND</span><span> </span><span>"timestamp"</span><span> </span><span>&lt;</span><span> </span><span>'2023-03-01'</span></code></div>
<div><code><span>GROUP BY</span><span> </span><span>"ts_month"</span></code></div>
<div><code><span>ORDER BY</span><span> </span><span>"ts_month"</span><span>;</span></code></div>
</div>
<p>&nbsp;</p>
<p><span data-contrast="none">Now as we inspect the query plan, we can see that the second query runs on 3 partitions and the total execution time was reduced significantly.</span><span data-ccp-props="{&quot;134233117&quot;:false,&quot;134233118&quot;:false,&quot;201341983&quot;:0,&quot;335551550&quot;:1,&quot;335551620&quot;:1,&quot;335559685&quot;:0,&quot;335559737&quot;:0,&quot;335559738&quot;:0,&quot;335559739&quot;:0,&quot;335559740&quot;:276}">&nbsp;</span></p>
<p><span data-contrast="none">A correct partitioning approach streamlines query execution and significantly reduces the time and resources required to fetch the desired data.</span><span data-ccp-props="{&quot;134233117&quot;:false,&quot;134233118&quot;:false,&quot;201341983&quot;:0,&quot;335551550&quot;:1,&quot;335551620&quot;:1,&quot;335559685&quot;:0,&quot;335559737&quot;:0,&quot;335559738&quot;:0,&quot;335559739&quot;:0,&quot;335559740&quot;:276}">&nbsp;</span></p>
<p><span data-contrast="none">With the next example we are going to examine the impact of utilizing indexes on query performance in CrateDB. The query returns the average temperature for each month and considers only temperature records higher than 20 and lower than -20 degrees. To examine the execution phases of this query we run it with <code>EXPLAIN ANALYZE</code>.</span><span data-ccp-props="{&quot;134233117&quot;:false,&quot;134233118&quot;:false,&quot;201341983&quot;:0,&quot;335551550&quot;:1,&quot;335551620&quot;:1,&quot;335559685&quot;:0,&quot;335559737&quot;:0,&quot;335559738&quot;:0,&quot;335559739&quot;:0,&quot;335559740&quot;:276}">&nbsp;</span></p>
<p><span data-contrast="none">The query employs the <code>abs()</code> function in the <code>WHERE</code> clause. During the query execution, <code>abs()</code> triggers a generic function scan, it doesn't directly benefit from the indexes on the temperature column which leads to a full-table scan. It means that the abs function requires evaluating the absolute value of the temperature of each single record which impacts the overall query performance.</span><span data-ccp-props="{&quot;134233117&quot;:false,&quot;134233118&quot;:false,&quot;201341983&quot;:0,&quot;335551550&quot;:1,&quot;335551620&quot;:1,&quot;335559685&quot;:0,&quot;335559737&quot;:0,&quot;335559738&quot;:0,&quot;335559739&quot;:0,&quot;335559740&quot;:276}">&nbsp;</span></p>
<p><span data-contrast="none">Changing the query to use direct comparison operators allows to use indexes. By running <code>EXPLAIN ANALYZE</code> we can observe that CrateDB now runs multiple queries which utilize underlying indexes to quickly locate and retrieve the relevant temperature records.</span><span data-ccp-props="{&quot;134233117&quot;:false,&quot;134233118&quot;:false,&quot;201341983&quot;:0,&quot;335551550&quot;:1,&quot;335551620&quot;:1,&quot;335559685&quot;:0,&quot;335559737&quot;:0,&quot;335559738&quot;:0,&quot;335559739&quot;:0,&quot;335559740&quot;:276}">&nbsp;</span></p>
<p><span data-contrast="none">This is one example where the right choice of predicates in your SQL queries can have a significant impact on performance. The execution trace shows you if a generic function query is executed of an index can be leveraged without evaluating each individual record. This has been a very simple example, please check the execution trace with your own queries. Similar effects can be achieved, for example, when sorting data. Using an index for sorting is highly beneficial over sorting in memory.</span><span data-ccp-props="{&quot;134233117&quot;:false,&quot;134233118&quot;:false,&quot;201341983&quot;:0,&quot;335551550&quot;:1,&quot;335551620&quot;:1,&quot;335559685&quot;:0,&quot;335559737&quot;:0,&quot;335559738&quot;:0,&quot;335559739&quot;:0,&quot;335559740&quot;:276}">&nbsp;</span></p>
<p><span data-contrast="none">In CrateDB, an array is a data type that allows you to store a sequence of elements of the same type. Because they can handle multiple values in a single, ordered structure, they are particularly useful for batch processing and the efficient representation of data sets. In the context of CrateDB, which is optimized for handling large-scale and time-series data, arrays can be used to store sequences of measurements which can significantly reduce the overall storage footprint. Let’s take a look at an example:</span><span data-ccp-props="{&quot;134233117&quot;:false,&quot;134233118&quot;:false,&quot;201341983&quot;:0,&quot;335551550&quot;:1,&quot;335551620&quot;:1,&quot;335559685&quot;:0,&quot;335559737&quot;:0,&quot;335559738&quot;:0,&quot;335559739&quot;:0,&quot;335559740&quot;:276}">&nbsp;</span></p>
<p><span data-contrast="none">The <code>CREATE TABLE</code> statement for <code>sensor_readings</code> in CrateDB is set up to store each sensor reading as an individual record. It includes a timestamp with a time zone for when the reading was taken, a text field for the sensor ID, a double-precision floating-point number for the battery level, and a text field for the battery status. This typical setup is suitable for scenarios where the frequency of data insertions is relatively low, or the storage and performance costs are not a primary concern. However, it can become inefficient when dealing with very large datasets, as each sensor reading is stored as a separate row, which can lead to a higher storage footprint and potentially slower query performance due to the higher number of rows to process.&nbsp;</span><span data-ccp-props="{&quot;134233117&quot;:false,&quot;134233118&quot;:false,&quot;201341983&quot;:0,&quot;335551550&quot;:1,&quot;335551620&quot;:1,&quot;335559685&quot;:0,&quot;335559737&quot;:0,&quot;335559738&quot;:0,&quot;335559739&quot;:0,&quot;335559740&quot;:276}">&nbsp;</span></p>
<p><span data-contrast="none">To tackle the challenge of efficiently storing a massive dataset, containing 120 million records which occupy 6 GiB of space we applied several optimizations:</span><span data-ccp-props="{&quot;134233117&quot;:false,&quot;134233118&quot;:false,&quot;201341983&quot;:0,&quot;335551550&quot;:1,&quot;335551620&quot;:1,&quot;335559685&quot;:0,&quot;335559737&quot;:0,&quot;335559738&quot;:0,&quot;335559739&quot;:0,&quot;335559740&quot;:276}">&nbsp;</span></p>
<p><span data-contrast="none">We restructured time data to be modeled as an array.</span><span data-ccp-props="{&quot;134233117&quot;:false,&quot;134233118&quot;:false,&quot;201341983&quot;:0,&quot;335551550&quot;:1,&quot;335551620&quot;:1,&quot;335559685&quot;:0,&quot;335559737&quot;:0,&quot;335559738&quot;:0,&quot;335559739&quot;:0,&quot;335559740&quot;:276}">&nbsp;</span></p>
<p><span data-contrast="none">The <code>time_bucket</code> field is truncated to the day level.</span><span data-ccp-props="{&quot;134233117&quot;:false,&quot;134233118&quot;:false,&quot;201341983&quot;:0,&quot;335551550&quot;:1,&quot;335551620&quot;:1,&quot;335559685&quot;:0,&quot;335559737&quot;:0,&quot;335559738&quot;:0,&quot;335559739&quot;:0,&quot;335559740&quot;:276}">&nbsp;</span></p>
<p><span data-contrast="none">Similarly, the actual sensor measurements are stored in arrays. This means that instead of one row per measurement, you have one row per time bucket.&nbsp;</span><span data-ccp-props="{&quot;134233117&quot;:false,&quot;134233118&quot;:false,&quot;201341983&quot;:0,&quot;335551550&quot;:1,&quot;335551620&quot;:1,&quot;335559685&quot;:0,&quot;335559737&quot;:0,&quot;335559738&quot;:0,&quot;335559739&quot;:0,&quot;335559740&quot;:276}">&nbsp;</span></p>
<p><span data-contrast="none">A more aggressive compression algorithm (e.g., <code>best_compression</code>) is applied to the table, taking advantage of the array structures.</span><span data-ccp-props="{&quot;134233117&quot;:false,&quot;134233118&quot;:false,&quot;201341983&quot;:0,&quot;335551550&quot;:1,&quot;335551620&quot;:1,&quot;335559685&quot;:0,&quot;335559737&quot;:0,&quot;335559738&quot;:0,&quot;335559739&quot;:0,&quot;335559740&quot;:276}">&nbsp;</span></p>
<p><span data-contrast="none">Indexes on the array fields are turned off to reduce the storage space used by indexes.&nbsp;</span><span data-ccp-props="{&quot;134233117&quot;:false,&quot;134233118&quot;:false,&quot;201341983&quot;:0,&quot;335551550&quot;:1,&quot;335551620&quot;:1,&quot;335559685&quot;:0,&quot;335559737&quot;:0,&quot;335559738&quot;:0,&quot;335559739&quot;:0,&quot;335559740&quot;:276}">&nbsp;</span></p>
<p><span data-contrast="none">By implementing these changes, the storage requirement was dramatically reduced from 6 GiB to 1.1 GiB, achieving an 80% reduction in storage space. This example illustrates how to leverage the array data type to reduce storage requirements and potentially improve query performance for time-series use cases.</span><span data-ccp-props="{&quot;134233117&quot;:false,&quot;134233118&quot;:false,&quot;201341983&quot;:0,&quot;335551550&quot;:1,&quot;335551620&quot;:1,&quot;335559685&quot;:0,&quot;335559737&quot;:0,&quot;335559738&quot;:0,&quot;335559739&quot;:0,&quot;335559740&quot;:276}">&nbsp;</span></p>
<p><span data-contrast="none">Another vital element of CrateDB's comprehensive feature set is the Common Table Expression, also known as CTE. CTEs serve as a potent instrument for enhancing the performance and readability of queries within CrateDB. In certain scenarios, such as those involving intricate queries that necessitate numerous filtering and aggregation steps, or when there's a need to repeatedly use a data subset within a single query, CTEs can provide performance advantages over traditional JOIN operations.</span><span data-ccp-props="{&quot;134233117&quot;:false,&quot;134233118&quot;:false,&quot;201341983&quot;:0,&quot;335551550&quot;:1,&quot;335551620&quot;:1,&quot;335559685&quot;:0,&quot;335559737&quot;:0,&quot;335559738&quot;:0,&quot;335559739&quot;:0,&quot;335559740&quot;:276}">&nbsp;</span></p>
<p><span data-contrast="none">Suppose we have three tables: the <code>sales</code> table records each sale transaction, the <code>sale_items</code> table details items within each sale and the <code>product</code> table which maintains information on each product. Now we want to find the total quantity sold for a specific product within a given date range. To calculate the total quantity of the product named Gadget sold within the date range from January 1, 2024, to February 1, 2024 the query joins <code>sales</code>, <code>sale_items</code>, and <code>products</code> tables based on their respective IDs. Even though this is a perfectly valid SQL it may not be the most efficient strategy.&nbsp;</span><span data-ccp-props="{&quot;134233117&quot;:false,&quot;134233118&quot;:false,&quot;201341983&quot;:0,&quot;335551550&quot;:1,&quot;335551620&quot;:1,&quot;335559685&quot;:0,&quot;335559737&quot;:0,&quot;335559738&quot;:0,&quot;335559739&quot;:0,&quot;335559740&quot;:276}">&nbsp;</span></p>
<p><span data-contrast="none">Even without considering the complexities of a distributed system, parallel processing, and disk/memory options there are still many different possible strategies here, for instance: “Gadget” product may be sold rarely, we could then start by looking up its <code>product_id</code>, then locate all instances of its sales in the <code>sale_items</code> table, and finally narrow down those sales to the specific date range in January 2024. If "Gadget" is a popular product in a dataset covering many years of sales, starting the query by selecting all sales made in January 2024 from the sales table, then identifying which of these sales include "Gadget" could be a more effective strategy.</span><span data-ccp-props="{&quot;134233117&quot;:false,&quot;134233118&quot;:false,&quot;201341983&quot;:0,&quot;335551550&quot;:1,&quot;335551620&quot;:1,&quot;335559685&quot;:0,&quot;335559737&quot;:0,&quot;335559738&quot;:0,&quot;335559739&quot;:0,&quot;335559740&quot;:276}">&nbsp;</span></p>
<p><span data-contrast="none">The impact of using a suboptimal execution plan here could be significant, as we could find ourselves trying to <code>JOIN</code> millions and millions of records.</span><span data-ccp-props="{&quot;134233117&quot;:false,&quot;134233118&quot;:false,&quot;201341983&quot;:0,&quot;335551550&quot;:1,&quot;335551620&quot;:1,&quot;335559685&quot;:0,&quot;335559737&quot;:0,&quot;335559738&quot;:0,&quot;335559739&quot;:0,&quot;335559740&quot;:276}">&nbsp;</span></p>
<p><span data-contrast="none">In our example, we consider the specific use case where our product 'Gadget' is a niche item with infrequent sales. The modified query we have constructed using Common Table Expressions efficiently isolates the relevant product ID first, reducing the subsequent search space to just the sales of this specific item before checking the corresponding sales records for the selected date range.</span><span data-ccp-props="{&quot;134233117&quot;:false,&quot;134233118&quot;:false,&quot;201341983&quot;:0,&quot;335551550&quot;:1,&quot;335551620&quot;:1,&quot;335559685&quot;:0,&quot;335559737&quot;:0,&quot;335559738&quot;:0,&quot;335559739&quot;:0,&quot;335559740&quot;:276}">&nbsp;</span></p>
<p><span data-contrast="none">In the <code>relevant_product_ids</code> CTE, we limit our initial search to the minimal set of relevant product entries, avoiding a full scan of the potentially large <code>sale_items</code> table.&nbsp;</span><span data-ccp-props="{&quot;134233117&quot;:false,&quot;134233118&quot;:false,&quot;201341983&quot;:0,&quot;335551550&quot;:1,&quot;335551620&quot;:1,&quot;335559685&quot;:0,&quot;335559737&quot;:0,&quot;335559738&quot;:0,&quot;335559739&quot;:0,&quot;335559740&quot;:276}">&nbsp;</span></p>
<p><span data-contrast="none">We then focus on the sale transactions associated with these <code>product_ids</code>, which is expected to be a small subset given the product's rarity, thus speeding up the process.</span><span data-ccp-props="{&quot;134233117&quot;:false,&quot;134233118&quot;:false,&quot;201341983&quot;:0,&quot;335551550&quot;:1,&quot;335551620&quot;:1,&quot;335559685&quot;:0,&quot;335559737&quot;:0,&quot;335559738&quot;:0,&quot;335559739&quot;:0,&quot;335559740&quot;:276}">&nbsp;</span></p>
<p><span data-contrast="none">Finally, by filtering the sales data for these specific <code>sale_items</code>, we ensure that we only consider the sales transactions that happened within our desired date range, January 2024.</span><span data-ccp-props="{&quot;134233117&quot;:false,&quot;134233118&quot;:false,&quot;201341983&quot;:0,&quot;335551550&quot;:1,&quot;335551620&quot;:1,&quot;335559685&quot;:0,&quot;335559737&quot;:0,&quot;335559738&quot;:0,&quot;335559739&quot;:0,&quot;335559740&quot;:276}">&nbsp;</span></p>
<p><span data-contrast="none">This stepwise refinement ensures that each subsequent join operation deals with the smallest possible dataset, leading to faster query performance and more efficient use of resources.</span><span data-ccp-props="{&quot;134233117&quot;:false,&quot;134233118&quot;:false,&quot;201341983&quot;:0,&quot;335551550&quot;:1,&quot;335551620&quot;:1,&quot;335559685&quot;:0,&quot;335559737&quot;:0,&quot;335559738&quot;:0,&quot;335559739&quot;:0,&quot;335559740&quot;:276}">&nbsp;</span></p>
<p><span data-contrast="none">Overall, CTEs make the query more readable and easier to maintain, especially for complex queries involving multiple steps. Furthermore, CTEs can keep the intermediate results, which can be beneficial if the same subset of data is used multiple times in the query, reducing the number of scans over the original table.</span><span data-ccp-props="{&quot;134233117&quot;:false,&quot;134233118&quot;:false,&quot;201341983&quot;:0,&quot;335551550&quot;:1,&quot;335551620&quot;:1,&quot;335559685&quot;:0,&quot;335559737&quot;:0,&quot;335559738&quot;:0,&quot;335559739&quot;:0,&quot;335559740&quot;:276}">&nbsp;</span></p>
<p><span data-contrast="none">Mastering time series query optimization in CrateDB is essential for ensuring efficient data processing. By integrating the strategies highlighted in this video, you'll be well-positioned to achieve optimal performance for your time-series analytics in CrateDB.</span><span data-ccp-props="{&quot;134233117&quot;:false,&quot;134233118&quot;:false,&quot;201341983&quot;:0,&quot;335551550&quot;:1,&quot;335551620&quot;:1,&quot;335559685&quot;:0,&quot;335559737&quot;:0,&quot;335559738&quot;:0,&quot;335559739&quot;:0,&quot;335559740&quot;:276}">&nbsp;</span></p>